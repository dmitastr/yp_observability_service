package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/dmitastr/yp_observability_service/internal/logger"
	"golang.org/x/tools/go/packages"
)

var resetMethodTemplate = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by resetmethodgenerate.go

package {{.Package}}

{{range .Entries}}
	func ({{.SelfName}} *{{.Name}}) Reset() {
		if {{.SelfName}} == nil {return}
		{{range .Fields}}
            {{if .ResetStmt}}
				{{if .IsPtr}}
					if {{.SelfName}}.{{.Name}} != nil {*{{.ResetStmt}}}
				{{else}}
					{{.ResetStmt}}
				{{end}}
			{{end}}
		{{end}}
		return
	}
{{end}}

`

var Resetter *types.Interface

// ResettableData stores all packages where we need to generate Reset method
type ResettableData struct {
	Pkgs map[string]*ResPkg
}

// ResPkg represents a Go package containing structs eligible for Reset method generation.
type ResPkg struct {
	Entries []*ResStruct
	Package string
	DirName string
}

// ResStruct represents a struct type for which a Reset method may be generated.
type ResStruct struct {
	Name     string
	Fields   []*Field
	SelfName string
}

// NewResetableStructEntry creates a new ResStruct with the given name and initializes its SelfName.
func NewResetableStructEntry(name string) *ResStruct {
	r := &ResStruct{Name: name}
	r.SetSelfName()
	return r
}

// SetSelfName assigns a lowercase version of the structâ€™s first letter as its SelfName.
// If the first character is not a letter, "r" is used instead.
func (r *ResStruct) SetSelfName() {
	selfName := []rune(r.Name)[0]
	if !unicode.IsLetter(selfName) {
		r.SelfName = "r"
		return
	}
	r.SelfName = strings.ToLower(string(selfName))
}

// Field represents a single struct field and its corresponding reset logic.
type Field struct {
	Name         string
	ResetStmt    string
	IsPtr        bool
	IsStruct     bool
	SelfName     string
	TypeOriginal types.Type
}

// getDefaultValue determines and assigns the default reset statement for a given field type.
func (f *Field) getDefaultValue(typ types.Type) {
	switch t := typ.(type) {
	case *types.Named:
		f.getDefaultValue(t.Underlying())

	case *types.Struct:
		if types.Implements(f.TypeOriginal, Resetter) || types.Implements(types.NewPointer(f.TypeOriginal), Resetter) {
			f.ResetStmt = fmt.Sprintf("%s.%s.Reset()", f.SelfName, f.Name)
			f.IsStruct = true
			return
		}
		logger.Infof("Type=%T does not implement Resetter\n", t)
		f.ResetStmt = ""

	case *types.Basic:
		switch t.Info() {
		case types.IsNumeric:
			f.ResetStmt = fmt.Sprintf("%s.%s=0", f.SelfName, f.Name)
		case types.IsString:
			f.ResetStmt = fmt.Sprintf("%s.%s=%q", f.SelfName, f.Name, "")
		case types.IsBoolean:
			f.ResetStmt = fmt.Sprintf("%s.%s=false", f.SelfName, f.Name)
		default:
			f.ResetStmt = fmt.Sprintf("%s.%s=0", f.SelfName, f.Name)
		}

	case *types.Pointer:
		f.getDefaultValue(t.Elem())
		if !f.IsStruct {
			f.IsPtr = true
		}

	case *types.Slice:
		f.ResetStmt = fmt.Sprintf("%s.%s=%s.%s[:0]", f.SelfName, f.Name, f.SelfName, f.Name)
	case *types.Map:
		f.ResetStmt = fmt.Sprintf("clear(%s.%s)", f.SelfName, f.Name)
	default:
		logger.Errorf("Unhandled type %T\n", t)
	}
}

// getPackageName returns the package name for the given Go package,
// falling back to the last path component if the name is empty.
func getPackageName(p *packages.Package) string {
	name := p.Name
	if name == "" {
		pkgPath := strings.Split(p.String(), "/")
		if len(pkgPath) > 0 {
			name = pkgPath[len(pkgPath)-1]
		}
	}
	return name
}

// getResetterInterface constructs and returns a new empty interface
// representing the Resetter interface with a Reset method.
func getResetterInterface() *types.Interface {
	r := types.NewInterfaceType([]*types.Func{
		types.NewFunc(0, nil, "Reset", types.NewSignatureType(nil, nil, nil, nil, nil, false)),
	}, nil).Complete()
	return r
}

func main() {
	Resetter = getResetterInterface()
	rd := ResettableData{Pkgs: make(map[string]*ResPkg)}
	doReset := "// generate:reset"
	fileName := "reset.gen.go"

	cfg := &packages.Config{
		Mode: packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedImports |
			packages.NeedDeps,
		Dir: ".",
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		panic(err)
	}
	for _, pkg := range pkgs {
		logger.Infof("Generating for package=%v\n", pkg)
		pkgName := getPackageName(pkg)
		rp, ok := rd.Pkgs[pkgName]
		if !ok {
			rp = &ResPkg{Package: pkgName, DirName: pkg.Dir}
		}

		for _, file := range pkg.Syntax {
			ast.Inspect(file, func(n ast.Node) bool {
				gd, ok := n.(*ast.GenDecl)
				if !ok {
					return true
				}
				for _, spec := range gd.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						return true
					}

					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						return true
					}

					if gd.Doc == nil {
						return true
					}

					logger.Infof("Struct type=%#v, name=%s\n", ts.Type, ts.Name.Name)

					for _, c := range gd.Doc.List {
						if c.Text != doReset {
							continue
						}
						rse := NewResetableStructEntry(ts.Name.Name)

						if st.Fields == nil {
							logger.Info("Type params are empty")
							return true
						}

						for _, field := range st.Fields.List {
							if len(field.Names) == 0 {
								logger.Info("Field names is empty")
								continue
							}

							fieldName := field.Names[0].Name
							logger.Infof("Field name=%s\n", fieldName)

							obj := pkg.TypesInfo.Defs[field.Names[0]]
							fieldType := obj.Type()

							fieldEntry := &Field{
								Name:         fieldName,
								SelfName:     rse.SelfName,
								TypeOriginal: fieldType,
							}
							fieldEntry.getDefaultValue(fieldType)
							logger.Infof("Field=%v, type=%v\n", fieldEntry, fieldType)

							rse.Fields = append(rse.Fields, fieldEntry)

						}
						rp.Entries = append(rp.Entries, rse)
						return true
					}
				}

				return true
			})
		}

		rd.Pkgs[pkgName] = rp
	}

	logger.Infof("Found packages with generate:reset directive:%#v\n", rd)

	tmpl := template.Must(template.New("resetTmpl").Parse(resetMethodTemplate))

	for _, rp := range rd.Pkgs {
		logger.Infof("Creating resettable structs for package=%s\n", rp.Package)
		if len(rp.Entries) == 0 {
			logger.Info("No resettable structs found")
			continue
		}

		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, rp); err != nil {
			logger.Error(err)
			continue
		}

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			logger.Error(err)
			continue
		}
		err = os.WriteFile(filepath.Join(rp.DirName, fileName), formatted, 0644)
		if err != nil {
			logger.Error(err)
			continue
		}

	}
}
